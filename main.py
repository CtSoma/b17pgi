# -*- coding: utf-8 -*-
"""Deployment_bbc_cnn_colab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1llR4OmCf34MEtjB6g7racKXXi_UL8rYa
"""

import torch
import nltk
from nltk.tokenize import word_tokenize
nltk.download('punkt')
import torch
import torch.nn as nn
import torch.nn.functional as F

#from google.colab import drive
#drive.mount('/content/drive')

"""**Uploading the dictionary of words, Embeddings, Topic List**"""

word2idx = torch.load('word2idx.pt', 'rb')
print(word2idx)

embeddings = torch.load('embeddings.pt')

topics = {
  0: "Politics",
  1: "Tech",
  2: "Business",
  3: 'Entertainment',
  4: 'Sports'
}

"""**Model Architecture**"""

class Model(nn.Module):
  def __init__(self,
               pretrained_embedding,
               ):

      super(Model, self).__init__()
      self.vocab_size, self.embed_dim = pretrained_embedding.shape
      self.embedding = nn.Embedding.from_pretrained(pretrained_embedding,
                                                          freeze=False)

            
        
      # Defining first convolution layer with input_channels = 300, output_channels = 100, kernel_size = 3
      self.conv1 = nn.Conv1d(in_channels=300, out_channels=100, kernel_size=3)
      # Defining second convolution layer with input channels = 300, output channels = 100, kernel_size= 4
      self.conv2 = nn.Conv1d(in_channels=300, out_channels=100, kernel_size=4)
      # Defining third convolution layer with input channels =300, output channels = 100, kernel_size =5
      self.conv3 = nn. Conv1d(in_channels= 300, out_channels= 100, kernel_size=5)

            
      # Define the Fully connected layers
      # Each of the channels will generate an element, so (100+100+100 =300)
      self.fc = nn.Linear(300, 5)
        
      self.dropout = nn.Dropout(0.5)
        
    
  def forward(self, dataset):

    x_embed = self.embedding(dataset).float()

    x_reshaped = x_embed.permute(0, 2, 1)
    
    x1 = F.relu(self.conv1(x_reshaped))
    x2 = F.relu(self.conv2(x_reshaped))
    x3 = F.relu(self.conv2(x_reshaped))

    x1_pool = F.max_pool1d(x1, kernel_size=x1.shape[2])
    x2_pool = F.max_pool1d(x2, kernel_size=x2.shape[2])
    x3_pool = F.max_pool1d(x3, kernel_size=x3.shape[2])

    
    x_fc = torch.cat([x1_pool.squeeze(dim=2), x2_pool.squeeze(dim=2), x3_pool.squeeze(dim=2)],
                         dim=1)
    logits = self.fc(self.dropout(x_fc))
    
    return logits

"""**Model upload**"""

model = Model(embeddings)
model.load_state_dict(torch.load('model.pth', map_location=torch.device('cpu')))
model.eval()

"""**Read and Predict**"""

article = input ()

"""Convert the input into tensor of indices using the dictionary"""

def predict(article):
  i=0
  idx_list=[]
  
  word_list= word_tokenize(str(article))
    
  for token in word_list:

    if word2idx.get(token) is not None:
      idx = word2idx.get(token)
    else:
      idx= 0
    idx_list.append(idx)
    
  
  
  if len(idx_list)>4862:
    idx_list = idx_list[:4862]
  
  pad_list = [0]*(4862- len(idx_list))
  idx_list = idx_list + pad_list
  idx_list = torch.tensor(idx_list)
 
  idx_list= torch.unsqueeze(idx_list, dim=0)
  _, predicted = torch.max(model(idx_list), 1)
  
  return topics[predicted.item()]

#predict(article)

@app.get('/')
def read_form():
    return 'hello world'
@app.get('/bbc')
def form_post(request:Request):
    res = 'Please enter Data'
    return templates.TemplateResponse('bbc.html',context  = {'request':request,'result':res})
@app.post('/bbc')
def form_post(request:Request,text1:string=Form(...),text2:string=Form(...)):
        result = predict([[text1]])
       # if result == 0:
        #    t = 'Versicolor'
        #    pic = 'https://cdn.pixabay.com/photo/2017/05/24/08/22/iris-2339883_1280.jpg'
        #elif result == 1:
        #    t = 'setosa'
        #   pic = 'https://cdn.pixabay.com/photo/2015/05/26/13/57/flower-784688__340.jpg'
        #else:
        #    t= 'virginica'
        #    pic = 'https://s3.amazonaws.com/eit-planttoolbox-prod/media/images/Iris-virginica--Jenny-Evans--CC-BY-NC.jpg'
        return templates.TemplateResponse('bbc.html',context = {'request':request,'result':result,'text1':text1,'text2':text2})